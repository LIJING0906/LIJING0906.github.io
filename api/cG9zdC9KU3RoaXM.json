{"title":"JS中的this指向问题","date":"2019-07-27T07:28:43.000Z","excerpt":"","slug":"JSthis","comments":true,"dropcap":true,"tags":["javaScript"],"categories":["javaScript"],"updated":"2019-12-01T13:34:23.000Z","content":"<p>在上篇JS继承中涉及到的好几个知识点都想写，比如<code>call()</code>、<code>apply()</code>从而牵出和<code>bind()</code>的区别，由<code>Object.create()</code>想到与<code>new Object()</code>、<code>{}</code>的区别，原型链以及作用域，然而在参考其他博客时发现，应该先把JS中的<code>this</code>指向弄明白。<br>《你不知道的JavaScript》(上卷)第二部分讲到了<code>this</code>，算是比较权威的关于<code>this</code>的讲解，但我觉得有些地方讲得还是晦涩难懂，需要结合一些博客来理解会容易理解一些。</p>\n<h1 id=\"为什么要用this\"><a href=\"#为什么要用this\" class=\"headerlink\" title=\"为什么要用this\"></a><strong>为什么要用this</strong></h1><p><code>this</code>提供一种优雅的方式来隐式“传递”一个对象引用，在函数中显示传入一个上下文对象，避免在代码越来越复杂的情况下造成上下文对象混乱。</p>\n<h1 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a><strong>this到底是什么</strong></h1><p><code>this</code>就像它的词性一样，是个代词，表指代什么，在JS中表示指代某个对象。<code>this</code>是在函数运行时绑定到某个对象上，并不是在函数定义时被绑定的，因此<code>this</code>的绑定（即<code>this</code>的指向）与函数的声明位置没关系，只取决于函数的调用方式。</p>\n<h1 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a><strong>绑定规则</strong></h1><p>说五种绑定规则之前，先说说不同作用域中<code>this</code>的指向，包括全局作用域（Global Scope）和局部作用域(Local Scope)。<br><strong>全局作用域（Global Scope）</strong><br>所有运行环境中JS运行时都只有唯一的全局对象，在浏览器中，全局对象是<code>window</code>;在<code>node.js</code>中全局对象是<code>global</code>。<br>在全局作用域中（任何函数体外的代码），<code>this</code>指向的是全局对象，不管是不是在严格模式下。<br><strong>局部作用域(Local Scope)</strong><br>局部作用域可以理解为<code>{}</code>包裹的区域，<code>this</code>的指向就根据调用方法不同而不同。</p>\n<h2 id=\"一、默认绑定\"><a href=\"#一、默认绑定\" class=\"headerlink\" title=\"一、默认绑定\"></a>一、默认绑定</h2><ol>\n<li><p><strong><em>独立函数调用</em></strong>，没有其他规则绑定时的默认规则，也是最常用的绑定规则，<code>this</code>指向全局对象<code>window</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>; </span><br><span class=\"line\">foo(); <span class=\"comment\">// Window对象  2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong><em>严格模式下</em></strong>，无法执行默认绑定把this绑定到全局对象上，因此，没有指定值时，<code>this</code>会绑定到<code>undefined</code>上。<br>虽然<code>this</code>的绑定规则完全取决于调用位置，但是只有<code>foo()</code><strong><em>运行</em></strong>在非严格模式下时，默认绑定才能把<code>this</code>绑定到全局对象；严格模式下<strong><em>调用</em></strong>函数则不影响默认绑定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 运行在严格模式下，this会绑定到undefined</span></span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里虽然foo()是在全局作用域中执行，但是foo里的代码运行在严格模式下，所以this被绑定到了undefined上。</span></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: Cannot read property 'a' of undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 严格模式下调用函数则不影响默认绑定</span></span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"二、隐式绑定\"><a href=\"#二、隐式绑定\" class=\"headerlink\" title=\"二、隐式绑定\"></a>二、隐式绑定</h2><p>当函数作为对象属性被调用时，函数中的<code>this</code>指向（被绑定到）调用这个函数的对象，这就是隐式绑定。注意：最后一层在调用中起作用，即最接近函数调用的那层起作用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>为什么是3？那就需要了解一下内存中基础类型数据和引用数据类型是怎么存储的，可以看看阮一峰的<a href=\"http://www.ruanyifeng.com/blog/2018/06/javascript-this.html\" target=\"_blank\" rel=\"noopener\">JavaScript的this原理</a>。<br>上面代码的执行过程：获取<code>obj.foo</code>属性——&gt;根据引用关系（引用地址）找到<code>foo</code>函数，执行函数调用。<code>obj</code>离<code>foo（）</code>最近，<code>this</code>被绑定到<code>obj</code>上。</p>\n<ol>\n<li>多层调用<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">4</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    obj1: obj1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.obj1.foo(); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同样看一下调用过程：获取<code>obj2.obj1</code>属性——&gt;根据引用关系（引用地址）获取<code>obj1</code>对象——&gt;再重复第二步找到<code>foo</code>函数——&gt;执行函数调用。<code>obj1</code>离<code>foo（）</code>最近，<code>this</code>被绑定到<code>obj1</code>上。</p>\n<ol start=\"2\">\n<li>隐式丢失（函数别名）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 把foo（）的引用地址赋值给bar</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>为什么没有隐式绑定到<code>obj</code>上？因为<code>obj.foo</code>是引用类型的属性，它其实是一个指向<code>foo()</code>函数的引用地址[打印一下obj.foo就能发现，打印出来的是foo函数]，因此<code>bar</code>得到的是<code>foo()</code>函数的引用地址，调用<code>bar()</code>时<code>this</code>被绑定到全局对象<code>window</code>上了。</p>\n<ol start=\"3\">\n<li>隐式丢失（回调函数）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fn其实引用的是foo</span></span><br><span class=\"line\">    fn(); <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// a是全局对象的属性</span></span><br><span class=\"line\">doFoo(obj.foo); <span class=\"comment\">// \"oops, global\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setTimeout</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等待delay毫秒</span></span><br><span class=\"line\">    fn(); <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>道理同函数别名的this绑定丢失一样。</p>\n<h2 id=\"三、显示绑定\"><a href=\"#三、显示绑定\" class=\"headerlink\" title=\"三、显示绑定\"></a>三、显示绑定</h2><p>通过<code>call()</code>或<code>apply()</code>方法。第一个参数是一个对象，在调用函数时将这个对象绑定到<code>this</code>上。因为直接指定<code>this</code>的绑定对象，称之为显示绑定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call(obj1); <span class=\"comment\">// 3 强制把this绑定到obj1上</span></span><br><span class=\"line\">foo.call(obj2); <span class=\"comment\">// 4 强制把this绑定到obj2上</span></span><br></pre></td></tr></table></figure></p>\n<p>显示绑定无法解决丢失绑定问题。<br>解决方案：</p>\n<ol>\n<li>硬绑定<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    foo.call(obj);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bar(); <span class=\"comment\">// 2 函数别名</span></span><br><span class=\"line\">setTimeout(bar, <span class=\"number\">100</span>); <span class=\"comment\">// 2 回调函数</span></span><br><span class=\"line\"><span class=\"comment\">// 硬绑定的bar不可能再修改它的this</span></span><br><span class=\"line\">bar.call(<span class=\"built_in\">window</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>典型应用场景是创建一个包裹函数，负责接收参数并返回值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a, something);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>创建一个可以重复使用的辅助函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 简单的辅助绑定函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind(foo, obj);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>ES5内置了<code>Function.prototype.bind</code>，<code>bind</code>会返回一个硬绑定的新函数，用法如下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a, something);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(obj);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">3</span>); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>API调用的“上下文”<br>JS许多内置函数提供了一个可选参数，被称之为“上下文”（<code>context</code>），其作用和<code>bind()</code>一样，确保回调函数使用指定的<code>this</code>。这些函数实际上通过<code>call()</code>和<code>apply()</code>实现了显式绑定。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(el, <span class=\"keyword\">this</span>.id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    id: <span class=\"string\">\"awesome\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"comment\">// 调用foo()时把this绑定到obj</span></span><br><span class=\"line\">myArray.forEach(foo, obj);</span><br><span class=\"line\"><span class=\"comment\">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"四、new绑定\"><a href=\"#四、new绑定\" class=\"headerlink\" title=\"四、new绑定\"></a>四、new绑定</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Func</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">new</span> Func();</span><br></pre></td></tr></table></figure>\n<p>看看<code>new</code>操作符具体做了什么就明白<code>new</code>绑定了。</p>\n<ol>\n<li><p>创建一个空对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置原型链</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.__proto__ = Func.prototype;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>让<code>Func</code>中的<code>this</code>指向<code>obj</code>，并执行<code>Func</code>的函数体。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = Func.call(obj);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断Func的返回值类型：<br>如果是值类型，返回<code>obj</code>。如果是引用类型，就返回这个引用类型的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(result) == <span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">  func = result;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    func = obj;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"五、箭头函数绑定\"><a href=\"#五、箭头函数绑定\" class=\"headerlink\" title=\"五、箭头函数绑定\"></a>五、箭头函数绑定</h2><p>箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this。</p>\n<ol>\n<li><p>正常调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>)</span>&#123;     </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;   </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 调用普通函数</span></span><br><span class=\"line\">obj1.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 调用箭头函数</span></span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// 2 根据外层作用域，obj2.foo指向的foo2函数的外层是全局对象，因此输出2</span></span><br><span class=\"line\">foo2.call(obj2); <span class=\"comment\">// 2 ，箭头函数中显示绑定不会生效</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数回调</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回调函数是普通函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 回调函数是箭头函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo2</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 此处返回的箭头函数的外层是foo2被调用的作用域，foo2将在obj2.foo()时被调用，此时的外层作用域时obj2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo1 </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; </span><br><span class=\"line\">    a: <span class=\"number\">3</span>,</span><br><span class=\"line\">    foo: foo2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 执行普通回调</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar1 = obj1.foo();</span><br><span class=\"line\">bar1(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 执行箭头回调</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar2 = obj2.foo();</span><br><span class=\"line\">bar2(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a><strong>优先级</strong></h1><p>优先级按照下面的顺序来进行判断: </p>\n<ol>\n<li>函数是否在<code>new</code>中调用(<code>new</code>绑定)？如果是的话<code>this</code>绑定的是新创建的对象。 </li>\n<li>函数是否通过<code>call</code>、<code>apply</code>(显式绑定)或者硬绑定调用？如果是的话，<code>this</code>绑定的是指定的对象。 </li>\n<li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，<code>this</code>绑定的是那个上下文对象。 </li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到<code>undefined</code>，否则绑定到全局对象。</li>\n</ol>\n<h1 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a><strong>绑定例外</strong></h1><p>在显示绑定中，把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p>\n<ol>\n<li>被忽略的this<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo.call(<span class=\"literal\">null</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\">foo.call(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实这不符合预期要求，如果某个函数确实使用了<code>this</code>，那会使用默认绑定把<code>this</code>绑定到全局对象上去。<br>安全的做法：传入一个特殊的对象（空对象），把<code>this</code>绑定到这个对象上，这样才不会对你的程序产生任何副作用。<br>JS中创建一个空对象最简单的方法是<code>Object.create(null)</code>，这个和<code>{}</code>很像，但是并不会创建<code>Object.prototype</code>这个委托，所以比<code>{}</code>更空。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\"，b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// 把数组”展开“成参数</span></span><br><span class=\"line\">foo.apply(ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// a:2，b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用bind()进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(ø, <span class=\"number\">2</span>);</span><br><span class=\"line\">bar(<span class=\"number\">3</span>); <span class=\"comment\">// a:2，b:3</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li><p>间接引用<br>间接引用时，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>软绑定<br>硬绑定可以把<code>this</code>强制绑定到指定的对象（<code>new</code>除外），防止函数调用时使用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改<code>this</code>。<br>如果给默认绑定指定一个全局对象和<code>undefined</code>以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改<code>this</code>的能力。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认绑定规则，优先级排最后</span></span><br><span class=\"line\"><span class=\"comment\">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Function</span>.prototype.softBind) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.softBind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 捕获所有curried参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(</span><br><span class=\"line\">                (!<span class=\"keyword\">this</span> || <span class=\"keyword\">this</span> === (<span class=\"built_in\">window</span> || global)) ? obj : <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                curried.concat.apply(curried, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = <span class=\"built_in\">Object</span>.create(fn.prototype);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>使用：软绑定版本的<code>foo()</code>可以手动将<code>this</code>绑定到<code>obj2</code>或者<code>obj3</code>上，但如果应用默认绑定，则会将<code>this</code>绑定到<code>obj</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"name:\"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj\"</span> &#125;,</span><br><span class=\"line\">    obj2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj2\"</span> &#125;,</span><br><span class=\"line\">    obj3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"obj3\"</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fooOBJ = foo.softBind(obj);</span><br><span class=\"line\">fooOBJ(); <span class=\"comment\">// name: obj </span></span><br><span class=\"line\"><span class=\"comment\">// 隐式绑定规则</span></span><br><span class=\"line\">obj2.foo = foo.softBind(obj);</span><br><span class=\"line\">obj2.foo(); <span class=\"comment\">// name: obj2 &lt;---- 看！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 显式绑定规则</span></span><br><span class=\"line\">fooOBJ.call(obj3); <span class=\"comment\">// name: obj3 &lt;---- 看！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 绑定丢失，应用软绑定</span></span><br><span class=\"line\">setTimeout(obj2.foo, <span class=\"number\">10</span>); <span class=\"comment\">// name: obj</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h1><p>我们在使用js的过程中，对于<code>this</code>的理解往往觉得比较困难，再调试过程中有时也会出现一些不符合预期的现象。很多时候，我们都是通过一些变通的方式（如：使用具体对象替换<code>this</code>）来规避的问题。</p>\n","prev":{"title":"call()、apply()、bind()的区别","slug":"callapplybind"},"next":{"title":"javaScript的继承方案","slug":"jsInherit"},"link":"/JSthis","toc":[{"title":"<strong>为什么要用this</strong>","id":"为什么要用this","index":"1"},{"title":"<strong>this到底是什么</strong>","id":"this到底是什么","index":"2"},{"title":"<strong>绑定规则</strong>","id":"绑定规则","index":"3","children":[{"title":"一、默认绑定","id":"一、默认绑定","index":"3.1"},{"title":"二、隐式绑定","id":"二、隐式绑定","index":"3.2"},{"title":"三、显示绑定","id":"三、显示绑定","index":"3.3"},{"title":"四、new绑定","id":"四、new绑定","index":"3.4"},{"title":"五、箭头函数绑定","id":"五、箭头函数绑定","index":"3.5"}]},{"title":"<strong>优先级</strong>","id":"优先级","index":"4"},{"title":"<strong>绑定例外</strong>","id":"绑定例外","index":"5"},{"title":"<strong>总结</strong>","id":"总结","index":"6"}]}