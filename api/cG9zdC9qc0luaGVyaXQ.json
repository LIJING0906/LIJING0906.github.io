{"title":"javaScript的继承方案","date":"2019-07-20T03:59:52.000Z","excerpt":"","slug":"jsInherit","comments":true,"dropcap":true,"tags":["javaScript"],"categories":["javaScript"],"updated":"2019-12-01T13:34:23.000Z","content":"<p>从创建这个博客开始，第一篇博客是2018.07.10，到今天2019.07.20已经整整一年了，回头看博客的数量才寥寥11篇，平均一个多月才一篇，汗颜！<br>最近有换工作的想法，但又觉自己的一些基础知识不牢固，同时这些基础知识也是面试中会考察的，所以给自己定下一个小目标，每周总结一篇面试中会考察的知识点，一为巩固知识，二为准备面试，三为自己养成一个擅于积累总结的好习惯。</p>\n<p>第一个要总结的就是javaScript的继承方案。javaScript的继承我一直不太理解，觉得很复杂，最近查阅了好些博客之后发现，需要结合图来理解就容易理解很多。</p>\n<h1 id=\"为什么需要继承\"><a href=\"#为什么需要继承\" class=\"headerlink\" title=\"为什么需要继承\"></a><strong>为什么需要继承</strong></h1><p>因为需要复用。一段代码需要复用可以用函数来实现，但是对象要复用呢，就需要继承。JS（ES6以下）不像其他强类型语言一样有类Class，所以只能通过原型来实现继承。</p>\n<h1 id=\"想要的继承效果\"><a href=\"#想要的继承效果\" class=\"headerlink\" title=\"想要的继承效果\"></a><strong>想要的继承效果</strong></h1><p>我们希望的是可以向构造函数传递参数实现实例对象的属性赋值，同时多个实例对象的属性相互不干扰，但函数是多个实例对象共享的。即属性不共享，函数共享。</p>\n<h1 id=\"继承依据的主要原理\"><a href=\"#继承依据的主要原理\" class=\"headerlink\" title=\"继承依据的主要原理\"></a><strong>继承依据的主要原理</strong></h1><p>原型链可以用来实现共享，构造函数可以让实例对象各自拥有自己的属性，互不干扰。</p>\n<p><strong><em>JS继承有很多种方式，各有千秋，我一一道来</em></strong></p>\n<p><strong><em>正式讲之前，先说一下构造函数、实例对象、原型对象之间的三角关系,一图胜千言</em></strong><br><img src=\"/2019/07/20/jsInherit/prototypeChain.png\" alt=\"\"></p>\n<p><strong><em>先声明父类构造函数，用于原型链继承和借用构造函数继承</em></strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"一、原型链继承\"><a href=\"#一、原型链继承\" class=\"headerlink\" title=\"一、原型链继承\"></a><strong>一、原型链继承</strong></h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Coder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Jane'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里是关键，创建Person的实例，并将该实例赋值给Coder.prototype</span></span><br><span class=\"line\">Coder.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> coder1 = <span class=\"keyword\">new</span> Coder();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(coder1.age); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(coder1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true。instanceof用于判断构造函数的prototype属性是否在实例对象的原型链上</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/20/jsInherit/protoInherit.png\" alt=\"\"><br><strong>疑惑点</strong>：属性<code>name</code>在实例<code>coder1</code>中而不在构造函数<code>Coder</code>中；属性<code>name</code>和<code>sayName</code>在<code>Coder.prototype</code>中而不在构造函数<code>Person</code>中。<br><strong>知识点</strong>：<code>name</code>和<code>sayName</code>都是实例属性，实例在哪里创建，实例属性就出现在哪里<br><strong>特点</strong>：实例可以继承的属性有：实例的构造函数的属性，父类构造函数的属性，父类原型的属性<br><strong>缺点</strong>：新实例无法向父类构造函数传参；多个实例共享属性导致实例对[<strong><em>引用类型</em></strong>]的操作会被篡改<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 演示：篡改父类引用类型的属性 colors是引用类型，height是基础类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]; <span class=\"comment\">// 【1】</span></span><br><span class=\"line\">    <span class=\"comment\">// this.height = 100; 【1`】</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Person.prototype.colors = ['red', 'blue', 'green']; // 【2】</span></span><br><span class=\"line\"><span class=\"comment\">// Person.prototype.height = 100; 【2`】</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Coder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this.colors = ['red', 'blue', 'green']; // 【3】</span></span><br><span class=\"line\">    <span class=\"comment\">// this.height = 100; 【3`】</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里是关键，创建Person的实例，并将该实例赋值给Coder.prototype</span></span><br><span class=\"line\">Coder.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> coder1 = <span class=\"keyword\">new</span> Coder();</span><br><span class=\"line\">coder1.colors.push(<span class=\"string\">'yellow'</span>);</span><br><span class=\"line\">coder1.height = <span class=\"number\">120</span>;</span><br><span class=\"line\"><span class=\"comment\">// 属性值沿着原型链，遵循就近原则。就近的属性值会屏蔽上层原型链的属性值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(coder1.colors, coder1.height); <span class=\"comment\">// ['red', 'blue', 'green', 'yellow'] 120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> coder2 = <span class=\"keyword\">new</span> Coder();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(coder2.colors, coder2.height);</span><br><span class=\"line\"><span class=\"comment\">// 【1】、【2】['red', 'blue', 'green', 'yellow']   【1`】、【2`】100；</span></span><br><span class=\"line\"><span class=\"comment\">// 【3】['red', 'blue', 'green']   【3`】100</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、借用构造函数继承\"><a href=\"#二、借用构造函数继承\" class=\"headerlink\" title=\"二、借用构造函数继承\"></a><strong>二、借用构造函数继承</strong></h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 借用构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Doctor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用.call()和.apply()将父类构造函数引入子类函数，等于是复制父类的实例属性给子类（不用原型）</span></span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, <span class=\"string\">'Summer'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> doctor1 = <span class=\"keyword\">new</span> Doctor();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(doctor1.name, doctor1.age); <span class=\"comment\">// Summer 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(doctor1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/20/jsInherit/constructorInherit.png\" alt=\"\"><br><strong>特点</strong>：可以向父类传参；可以继承多个构造函数属性（<code>call</code>多个）；每个实例属性各自独立，解决原型链继承中共享属性的问题<br><strong>缺点</strong>：只能继承父类构造函数的属性和方法，不能继承父类原型的属性和方法；无法实现函数复用，每个子类实例都有父类构造函数的副本，影响性能</p>\n<h1 id=\"三、组合继承-常用\"><a href=\"#三、组合继承-常用\" class=\"headerlink\" title=\"三、组合继承(常用)\"></a><strong>三、组合继承</strong>(常用)</h1><p>结合了以上两种模式的优点，传参和复用。利用原型链实现对父类原型属性和方法的继承，借用构造函数实现对父类构造函数的属性的继承。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合继承的实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明父类，构造函数内有基础类型属性和引用类型属性，原型上有一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Driver</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第二次调用Person()</span></span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 借用构造函数模式实现属性继承</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一次调用Person()</span></span><br><span class=\"line\">Driver.prototype = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">// 原型链继承实现方法继承</span></span><br><span class=\"line\"><span class=\"comment\">// 重写Driver.prototype的constructor属性，指向自己的构造函数Driver</span></span><br><span class=\"line\">Driver.prototype.constructor = Driver; </span><br><span class=\"line\">Driver.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> driver1 = <span class=\"keyword\">new</span> Driver(<span class=\"string\">'Nike'</span>, <span class=\"number\">29</span>);</span><br><span class=\"line\">driver1.colors.push(<span class=\"string\">'yellow'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driver1.colors); <span class=\"comment\">// ['red', 'blue', 'green', 'yellow']</span></span><br><span class=\"line\">driver1.sayName(); <span class=\"comment\">// 'Nike'</span></span><br><span class=\"line\">driver1.sayAge(); <span class=\"comment\">// 29</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> driver2 = <span class=\"keyword\">new</span> Driver(<span class=\"string\">'Greg'</span>, <span class=\"number\">27</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driver2.colors); <span class=\"comment\">// ['red', 'blue', 'green']</span></span><br><span class=\"line\">driver2.sayName(); <span class=\"comment\">// 'Greg'</span></span><br><span class=\"line\">driver2.sayAge(); <span class=\"comment\">// 27</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/07/20/jsInherit/togetherInherit.png\" alt=\"\"><br><strong>特点</strong>：可以继承父类原型上的属性，可以传参，可复用；每个新实例传入构造函数的属性是私有的<br><strong>缺点</strong>：使用子类创建实例对象时，其原型中会存在两份相同的属性/方法，即两次调用<code>Person()</code>创建实例的时候都往<code>Person.prototype</code>写入了<code>name</code>和<code>age</code>两个属性</p>\n<h1 id=\"四、原型式继承\"><a href=\"#四、原型式继承\" class=\"headerlink\" title=\"四、原型式继承\"></a><strong>四、原型式继承</strong></h1><p>利用一个空构造函数作为中介，将某个对象直接赋值给空构造函数的原型<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原型式继承的实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数容器，用来输出对象和承载继承的原型</span></span><br><span class=\"line\"><span class=\"comment\">// object()对传入其中的对象执行了一次[浅复制]，将构造函数F的原型直接指向传入的对象</span></span><br><span class=\"line\"><span class=\"comment\">// ES5中存在Object.create()的方法，能够代替object方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> PersonA = object(person);</span><br><span class=\"line\">PersonA.name = <span class=\"string\">'Greg'</span>;</span><br><span class=\"line\">PersonA.friends.push(<span class=\"string\">'d'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> PersonB = object(person);</span><br><span class=\"line\">PersonB.name = <span class=\"string\">'Linda'</span>;</span><br><span class=\"line\">PersonB.friends.push(<span class=\"string\">'e'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends); <span class=\"comment\">// ['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/07/20/jsInherit/objectInherit.png\" alt=\"\"><br><strong>缺点</strong>：多个实例的引用类型属性指向相同，存在篡改的可能；无法传参</p>\n<h1 id=\"五、寄生式继承\"><a href=\"#五、寄生式继承\" class=\"headerlink\" title=\"五、寄生式继承\"></a><strong>五、寄生式继承</strong></h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生式继承的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> clone = object(original); <span class=\"comment\">// 通过调用 object() 函数创建一个新对象</span></span><br><span class=\"line\">    clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  <span class=\"comment\">// 以某种方式来增强对象,可以是新增属性或方法，这里是新增方法</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone; <span class=\"comment\">// 返回这个对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    friends: [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> PersonC = createAnother(person);</span><br><span class=\"line\">PersonC.sayHi(); <span class=\"comment\">// 'hi'</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/20/jsInherit/parasiticInherit.png\" alt=\"\"><br><strong>特点</strong>：在原型式继承的基础上，增强对象<br><strong>缺点</strong>：同原型式继承</p>\n<h1 id=\"六、寄生组合式继承-常用\"><a href=\"#六、寄生组合式继承-常用\" class=\"headerlink\" title=\"六、寄生组合式继承(常用)\"></a><strong>六、寄生组合式继承</strong>(常用)</h1><p>第三种继承方式————组合继承虽然实现了需求:共享函数，但不共享属性，可是它是有不足之处：我们在独立属性时只是希望实例有各自的属性就好了，不需要原型（<code>SubType.prototype</code>）中也存在属性，这就多余了。<br><code>SubType.prototype</code>存在属性是因为它对<code>SuperType</code>做了实例化继承，我们将实例化继承换成浅拷贝继承便可以解决问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寄生组合式继承的实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将组合继承中的实例化继承：</span></span><br><span class=\"line\"><span class=\"comment\">//Driver.prototype = new Person();</span></span><br><span class=\"line\"><span class=\"comment\">//改为浅拷贝继承：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(superType.prototype); <span class=\"comment\">// 创建对象，创建父类原型的一个副本</span></span><br><span class=\"line\">    prototype.constructor = subType; <span class=\"comment\">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class=\"line\">    subType.prototype = prototype;  <span class=\"comment\">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类初始化实例属性和原型属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Driver</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将父类原型指向子类</span></span><br><span class=\"line\">inheritPrototype(Driver, Person);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新增子类原型属性</span></span><br><span class=\"line\">Driver.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> driverA = <span class=\"keyword\">new</span> Driver(<span class=\"string\">'Jane'</span>, <span class=\"number\">23</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> driverB = <span class=\"keyword\">new</span> Driver(<span class=\"string\">'Summer'</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">driverA.colors.push(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">driverB.colors.push(<span class=\"string\">'3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driverA.colors); <span class=\"comment\">// ['red', 'blue', 'green', '2']</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(driverB.colors); <span class=\"comment\">// ['red', 'blue', 'green', '3']</span></span><br><span class=\"line\"></span><br><span class=\"line\">driverA.sayAge(); <span class=\"comment\">// 23</span></span><br><span class=\"line\">driverA.sayName(); <span class=\"comment\">// Jane</span></span><br><span class=\"line\"></span><br><span class=\"line\">driverB.sayAge(); <span class=\"comment\">// 25</span></span><br><span class=\"line\">driverB.sayName(); <span class=\"comment\">// Summer</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2019/07/20/jsInherit/togetherInherit2.png\" alt=\"\"><br><strong>特点</strong>：高效率，因为只调用了一次构造函数<code>Person</code>，因此避免了在<code>Driver.prototype</code>上创建不必要的、多余的属性；原型链保持不变，可以正常使用<code>instanceof</code>和<code>isPrototypeOf()</code><br><strong>这是最成熟的方法，也是现在实现库的方法</strong></p>\n","prev":{"title":"JS中的this指向问题","slug":"JSthis"},"next":{"title":"vue混入mixins用法小结","slug":"vuemixins"},"link":"/jsInherit","toc":[{"title":"<strong>为什么需要继承</strong>","id":"为什么需要继承","index":"1"},{"title":"<strong>想要的继承效果</strong>","id":"想要的继承效果","index":"2"},{"title":"<strong>继承依据的主要原理</strong>","id":"继承依据的主要原理","index":"3"},{"title":"<strong>一、原型链继承</strong>","id":"一、原型链继承","index":"4"},{"title":"<strong>二、借用构造函数继承</strong>","id":"二、借用构造函数继承","index":"5"},{"title":"<strong>三、组合继承</strong>(常用)","id":"三、组合继承-常用","index":"6"},{"title":"<strong>四、原型式继承</strong>","id":"四、原型式继承","index":"7"},{"title":"<strong>五、寄生式继承</strong>","id":"五、寄生式继承","index":"8"},{"title":"<strong>六、寄生组合式继承</strong>(常用)","id":"六、寄生组合式继承-常用","index":"9"}]}