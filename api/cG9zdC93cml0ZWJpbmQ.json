{"title":"模拟实现bind()","date":"2019-09-07T02:21:47.000Z","excerpt":"","slug":"writebind","comments":true,"dropcap":true,"tags":["javaScript"],"categories":["javaScript"],"updated":"2019-12-01T13:34:23.000Z","content":"<p>前面已经讨论过<code>bind()</code>的用法，这篇文章一步一步模拟实现<code>bind()</code>。</p>\n<h1 id=\"bind特点\"><a href=\"#bind特点\" class=\"headerlink\" title=\"bind特点\"></a><strong>bind特点</strong></h1><ol>\n<li>可以指定this</li>\n<li>返回一个函数</li>\n<li>可以传入参数</li>\n</ol>\n<h2 id=\"模拟实现第一步\"><a href=\"#模拟实现第一步\" class=\"headerlink\" title=\"模拟实现第一步\"></a>模拟实现第一步</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">// this是调用bind2的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.apply(context); <span class=\"comment\">// 把this绑定给传入的上下文对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bf = bar.bind2(foo);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bf()); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"模拟实现第二步—-传参\"><a href=\"#模拟实现第二步—-传参\" class=\"headerlink\" title=\"模拟实现第二步—-传参\"></a>模拟实现第二步—-传参</h2><p>先看一个例子，在<code>bind()</code>的时候可以传参，在调用函数的又可以传参：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bf = bar.bind(foo, <span class=\"string\">'Jane'</span>);</span><br><span class=\"line\">bf(<span class=\"number\">20</span>); <span class=\"comment\">// 2 Jane 20</span></span><br><span class=\"line\"><span class=\"comment\">// bar.bind(foo, 'Jane')(20); // 2 Jane 20   把bind和调用写在一起</span></span><br></pre></td></tr></table></figure></p>\n<p>可以用<code>arguments</code>进行处理：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取bind时传入的参数，因为bind的第一个参数是指定的this，因此从第二个参数开始截取</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取返回的函数传入的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.apply(context, args.concat(bindArgs)); <span class=\"comment\">// 合并两次获取到的参数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>.value,</span><br><span class=\"line\">        name: name,</span><br><span class=\"line\">        age: age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bf = bar.bind2(foo, <span class=\"string\">'Jane'</span>);</span><br><span class=\"line\">bf(<span class=\"number\">20</span>); <span class=\"comment\">// &#123; value: 2, name: \"Jane\", age: 20 &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模拟实现第三步\"><a href=\"#模拟实现第三步\" class=\"headerlink\" title=\"模拟实现第三步\"></a>模拟实现第三步</h2><p>到上面的第二步，大部分的功能已经实现，但是还有一个难点，<code>bind()</code>有一个特性：</p>\n<blockquote>\n<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的this值被忽略，同时调用时的参数被提供给模拟函数。</p>\n</blockquote>\n<p>也就是说，当<code>bind()</code>返回的函数作为构造函数的时候，<code>bind</code>时指定的<code>this</code>值会失效，但传入的参数依然生效。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.habit = <span class=\"string\">'shopping'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.prototype.friend = <span class=\"string\">'kevin'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFoo = bar.bind(foo, <span class=\"string\">'Jane'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> bindFoo(<span class=\"number\">20</span>); <span class=\"comment\">// undefined \"Jane\" 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.habit); <span class=\"comment\">// \"shopping\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.friend); <span class=\"comment\">// \"kevin\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的例子中，运行结果<code>this.value</code>输出是<code>undefined</code>，这个值既不是全局的<code>value</code>也不是<code>foo</code>对象的<code>value</code>，这说明<code>bind</code>的<code>this</code>失效了，而<code>new</code>操作符生成了一个新的对象，这个时候<code>this</code>指向的是<code>obj</code>。</p>\n<p>OK，我们可以通过修改返回函数的原型来实现这种效果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fBound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当作为构造函数时，this指向实例，此时`this instanceof fBound`结果为true，可以让实例获得来自绑定函数的值，即上例中实例会具有habit属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 当作为普通函数时，this指向window，此时结果为false，将绑定函数的this指向context</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.apply(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fBound ? <span class=\"keyword\">this</span> : context, args.concat(bindArgs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 修改返回函数的prototype为绑定函数的prototype，实例就可以继承绑定函数的原型中的值，即上例中obj可以获取到bar原型上的friend</span></span><br><span class=\"line\">    fBound.prototype = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fBound;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 测试直接用上面的例子把bind改成bind2即可测试，效果跟原生的bind一样</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模拟实现第四步\"><a href=\"#模拟实现第四步\" class=\"headerlink\" title=\"模拟实现第四步\"></a>模拟实现第四步</h2><p>上面实现中<code>fBound.prototype = this.prototype</code>有一个缺点，直接修改<code>fBound.prototype</code>的时候，也会直接修改<code>this.prototype</code>。<br>可以用一个空函数来中转：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fBound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当作为构造函数时，this指向实例，此时`this instanceof fBound`结果为true，可以让实例获得来自绑定函数的值，即上例中实例会具有habit属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 当作为普通函数时，this指向window，此时结果为false，将绑定函数的this指向context</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.apply(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fBound ? <span class=\"keyword\">this</span> : context, args.concat(bindArgs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 修改返回函数的prototype为绑定函数的prototype，实例就可以继承绑定函数的原型中的值，即上例中obj可以获取到bar原型上的friend</span></span><br><span class=\"line\">    fNOP.prototype = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">    fBound.prototype = <span class=\"keyword\">new</span> fNOP();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fBound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模拟实现第五步\"><a href=\"#模拟实现第五步\" class=\"headerlink\" title=\"模拟实现第五步\"></a>模拟实现第五步</h2><p>这一步要做一个判断：如果调用<code>bind()</code>的不是函数，需要抛出异常：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Function.prototype.bind - what is trying to be bound is not callable\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fNOP = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fBound = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bindArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.apply(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> fNOP ? <span class=\"keyword\">this</span> : context, args.concat(bindArgs));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fNOP.prototype = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">        fBound.prototype = <span class=\"keyword\">new</span> fNOP();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fBound;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"赋值、浅拷贝和深拷贝的区别","slug":"copy"},"next":{"title":"模拟实现call()、apply()","slug":"writeallapply"},"link":"/writebind","toc":[{"title":"<strong>bind特点</strong>","id":"bind特点","index":"1","children":[{"title":"模拟实现第一步","id":"模拟实现第一步","index":"1.1"},{"title":"模拟实现第二步—-传参","id":"模拟实现第二步—-传参","index":"1.2"},{"title":"模拟实现第三步","id":"模拟实现第三步","index":"1.3"},{"title":"模拟实现第四步","id":"模拟实现第四步","index":"1.4"},{"title":"模拟实现第五步","id":"模拟实现第五步","index":"1.5"},{"title":"最终代码","id":"最终代码","index":"1.6"}]}]}