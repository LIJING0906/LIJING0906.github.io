{"title":"var、let和const的区别","date":"2020-07-26T04:50:02.000Z","excerpt":"","slug":"varletconst","comments":true,"dropcap":true,"tags":["javaScript","ES6"],"categories":["JS"],"updated":"2020-07-26T09:13:48.809Z","content":"<p>入职两个月了，总结也迟到两个月了。<br>因为疫情的原因，今年的面试大多是远程面试，所以几乎每次面试都有做相应的问题笔记。从这篇博客开始，把面试中问到的问题做个总结，一是复盘面试中自己的问题，二呢也是为以后的面试做准备。<br>参考阮大大的<a href=\"https://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">let 和 const 命令</a></p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h1><p><code>ES5</code>只有全局作用域和函数作用域，就会出现<strong>内层变量可能会覆盖外层变量</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。<br>还有一种场景，<strong>用来计数的循环变量泄露为全局变量</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<br><code>ES6</code>开始增加了块级作用域，<strong>所声明的变量，只在<code>let/const</code>命令所在的代码块内有效</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出<code>5</code>。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是<code>10</code>。<br><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为<code>JavaScript</code>引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a><strong>变量提升</strong></h1><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。<br>为了纠正这种现象，<code>let/const</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>\n<h1 id=\"ES6暂时性死区\"><a href=\"#ES6暂时性死区\" class=\"headerlink\" title=\"ES6暂时性死区\"></a><strong>ES6暂时性死区</strong></h1><p>只要块级作用域内存在<code>let/const</code>命令，它所声明的变量就“绑定”（<code>binding</code>）这个区域，不再受外部的影响。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。<br><strong><code>ES6</code>明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错</strong>。<br>总之，<code>在代码块内，使用let命令声明变量之前，该变量都是不可用的</code>。<strong>这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TDZ开始</span></span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。<br>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。<br>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“<code>undefined</code>”。所以，<strong>在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错</strong>。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>\n<p><code>ES6</code>规定暂时性死区和<code>let、const</code>语句不出现变量提升，主要是为了<strong>减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为</strong>。这样的错误在<code>ES5</code>是很常见的，现在有了这种规定，避免此类错误就很容易了。<br>总之，<strong>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p>\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a><strong>不允许重复声明</strong></h1><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因此，不能在函数内部重新声明参数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不报错</span></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure></p>\n<p><strong>块级作用域与函数声明参见</strong><a href=\"https://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E\" target=\"_blank\" rel=\"noopener\">点此跳转</a>查看阮大大博客</p>\n<h1 id=\"let和函数声明只能出现在作用域顶部\"><a href=\"#let和函数声明只能出现在作用域顶部\" class=\"headerlink\" title=\"let和函数声明只能出现在作用域顶部\"></a><strong>let和函数声明只能出现在作用域顶部</strong></h1><p><code>ES6</code>的块级作用域必须有大括号，如果没有大括号，<code>JavaScript</code>引擎就认为不存在块级作用域。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种写法，报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法，不报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。<br>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a><strong>const</strong></h1><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">PI = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码表明改变常量的值会报错。<br><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>\n<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MAX <span class=\"comment\">// Uncaught ReferenceError: MAX is not defined</span></span><br></pre></td></tr></table></figure></p>\n<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(MAX); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。<br><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两行都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">\"Goodbye!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是<strong>变量指向的那个内存地址不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 为 foo 添加一个属性，可以成功</span></span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\">foo.prop <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 指向另一个对象，就会报错</span></span><br><span class=\"line\">foo = &#123;&#125;; <span class=\"comment\">// TypeError: \"foo\" is read-only</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br>下面是另一个例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">'Dave'</span>];    <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。<br>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></span><br><span class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。<br>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> constantize = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach( <span class=\"function\">(<span class=\"params\">key, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span> ) &#123;</span><br><span class=\"line\">      constantize( obj[key] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ES6声明变量的六种方法\"><a href=\"#ES6声明变量的六种方法\" class=\"headerlink\" title=\"ES6声明变量的六种方法\"></a><strong>ES6声明变量的六种方法</strong></h1><p><code>ES5</code>只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。<code>ES6</code>除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，<code>ES6</code>一共有<code>6</code>种声明变量的方法。</p>\n<p><strong>顶层对象的属性</strong><a href=\"https://es6.ruanyifeng.com/#docs/let#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">点此跳转</a>阮大大博客查看<br><strong>globalThis对象</strong><a href=\"https://es6.ruanyifeng.com/#docs/let#globalThis-%E5%AF%B9%E8%B1%A1\" target=\"_blank\" rel=\"noopener\">点此跳转</a>阮大大博客查看</p>\n","prev":{"title":"什么是BFC？BFC有什么用？BFC怎么用？","slug":"BFC"},"next":{"title":"Promise面试题","slug":"promiseTest"},"link":"/varletconst","toc":[{"title":"<strong>作用域</strong>","id":"作用域","index":"1"},{"title":"<strong>变量提升</strong>","id":"变量提升","index":"2"},{"title":"<strong>ES6暂时性死区</strong>","id":"ES6暂时性死区","index":"3"},{"title":"<strong>不允许重复声明</strong>","id":"不允许重复声明","index":"4"},{"title":"<strong>let和函数声明只能出现在作用域顶部</strong>","id":"let和函数声明只能出现在作用域顶部","index":"5"},{"title":"<strong>const</strong>","id":"const","index":"6"},{"title":"<strong>ES6声明变量的六种方法</strong>","id":"ES6声明变量的六种方法","index":"7"}]}